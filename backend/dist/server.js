/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./backend/api.js":
/*!************************!*\
  !*** ./backend/api.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.acceptFriendRequest = acceptFriendRequest;\nexports.addActivityEntry = addActivityEntry;\nexports.addDiscussionEntry = addDiscussionEntry;\nexports.addMemberToProject = addMemberToProject;\nexports.asp = asp;\nexports.authenticateUser = authenticateUser;\nexports.closeDatabaseConnection = closeDatabaseConnection;\nexports.connectToMongoDB = connectToMongoDB;\nexports.createProject = createProject;\nexports.declineFriendRequest = declineFriendRequest;\nexports.deleteProject = deleteProject;\nexports.deleteUser = deleteUser;\nexports.getActivityFeed = getActivityFeed;\nexports.getAllProjects = getAllProjects;\nexports.getAllTypes = getAllTypes;\nexports.getDiscussions = getDiscussions;\nexports.getProject = getProject;\nexports.getProjectFiles = getProjectFiles;\nexports.getProjectType = getProjectType;\nexports.getUser = getUser;\nexports.getUserById = getUserById;\nexports.pinProjectToUser = pinProjectToUser;\nexports.promoteMemberToOwner = promoteMemberToOwner;\nexports.removeFriend = removeFriend;\nexports.searchAll = searchAll;\nexports.searchUsers = searchUsers;\nexports.sendFriendRequest = sendFriendRequest;\nexports.signupUser = signupUser;\nexports.updateProject = updateProject;\nexports.updateUserInfo = updateUserInfo;\nexports.userProjects = userProjects;\nvar _mongodb = __webpack_require__(/*! mongodb */ \"mongodb\");\nvar _dotenv = _interopRequireDefault(__webpack_require__(/*! dotenv */ \"dotenv\"));\nvar _path = _interopRequireDefault(__webpack_require__(/*! path */ \"path\"));\nvar _url = __webpack_require__(/*! url */ \"url\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst _filename = (0, _url.fileURLToPath)(\"file:///C:/Users/Okail/OneDrive/Desktop/IMY220/project/u23527685IMY220Project/backend/api.js\");\nconst _dirname = _path.default.dirname(_filename);\n_dotenv.default.config({\n  path: _path.default.resolve(_dirname, '.env')\n});\nconst connectionString = process.env.MONGODB_URI;\nconst dbName = process.env.DB_NAME;\nlet client;\nlet db;\nasync function connectToMongoDB() {\n  try {\n    if (!connectionString || !dbName) {\n      throw new Error(\"Missing MONGODB_URI or DB_NAME environment variables\");\n    }\n    client = new _mongodb.MongoClient(connectionString);\n    await client.connect();\n    db = client.db(dbName);\n    console.log('Connected to MongoDB');\n    return db;\n  } catch (error) {\n    console.error('Failed to connect to MongoDB:', error);\n    throw error;\n  }\n}\nasync function authenticateUser({\n  username,\n  password\n}) {\n  try {\n    if (!username || !password) {\n      return {\n        success: false,\n        message: \"Username and password are required\",\n        errorCode: \"MISSING_CREDENTIALS\"\n      };\n    }\n    const user = await db.collection('users').findOne({\n      username: new RegExp(`^${username}$`, 'i'),\n      password: password\n    });\n    if (!user) {\n      return {\n        success: false,\n        message: \"Invalid username or password\",\n        errorCode: \"INVALID_CREDENTIALS\"\n      };\n    }\n    return {\n      success: true,\n      message: \"User logged in successfully\",\n      user: user\n    };\n  } catch (error) {\n    console.error('Error authenticating user:', error);\n    return {\n      success: false,\n      message: \"Authentication failed due to server error\",\n      errorCode: \"AUTH_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function signupUser({\n  username,\n  password,\n  email\n}) {\n  try {\n    if (!username || !password || !email) {\n      return {\n        success: false,\n        message: \"Username, password, and email are required\",\n        errorCode: \"MISSING_FIELDS\"\n      };\n    }\n\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      return {\n        success: false,\n        message: \"Invalid email format\",\n        errorCode: \"INVALID_EMAIL\"\n      };\n    }\n    const existingUser = await db.collection('users').findOne({\n      $or: [{\n        username: new RegExp(`^${username}$`, 'i')\n      }, {\n        email: new RegExp(`^${email}$`, 'i')\n      }]\n    });\n    if (existingUser) {\n      return {\n        success: false,\n        message: \"Username or email already exists\",\n        errorCode: \"USER_EXISTS\"\n      };\n    }\n    const newUser = {\n      username,\n      password,\n      email,\n      profileImage: \"default user\",\n      personalInfo: {\n        birthday: null,\n        work: null,\n        contactInfo: [email],\n        bio: null,\n        socials: [],\n        website: null\n      },\n      friends: [],\n      friendRequestsSent: [],\n      friendRequestsReceived: [],\n      ownedProjects: [],\n      memberOfProjects: [],\n      favoriteLanguages: [],\n      role: \"registered_user\",\n      isVerified: false,\n      verificationRequest: null,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      name: null,\n      surname: null,\n      savedProjects: []\n    };\n    const result = await db.collection('users').insertOne(newUser);\n    if (result.insertedId) {\n      return {\n        success: true,\n        message: \"User signed up successfully\",\n        user: newUser\n      };\n    } else {\n      throw new Error('Failed to create user');\n    }\n  } catch (error) {\n    console.error('Error signing up user:', error);\n    return {\n      success: false,\n      message: \"Signup failed due to server error\",\n      errorCode: \"SIGNUP_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getAllProjects() {\n  try {\n    const projects = await db.collection('projects').find({}).toArray();\n    return {\n      success: true,\n      projects: projects\n    };\n  } catch (error) {\n    console.error(\"Error getting projects:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve projects\",\n      errorCode: \"FETCH_PROJECTS_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function closeDatabaseConnection() {\n  try {\n    if (client) {\n      await client.close();\n      console.log('MongoDB connection closed');\n    }\n  } catch (error) {\n    console.error('Error closing MongoDB connection:', error);\n  }\n}\nasync function userProjects(userid) {\n  try {\n    if (!userid) {\n      return {\n        success: false,\n        message: \"User ID is required\",\n        errorCode: \"MISSING_USER_ID\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(userid)) {\n      return {\n        success: false,\n        message: \"Invalid user ID format\",\n        errorCode: \"INVALID_USER_ID\"\n      };\n    }\n    const userObjectId = new _mongodb.ObjectId(userid);\n    const projects = await db.collection('projects').find({\n      $or: [{\n        owner: userObjectId\n      }, {\n        members: {\n          $in: [userObjectId]\n        }\n      }]\n    }).toArray();\n    const ownedProjects = [];\n    const memberOfProjects = [];\n    projects.forEach(project => {\n      if (project.owner.equals(userObjectId)) {\n        ownedProjects.push(project);\n      } else {\n        memberOfProjects.push(project);\n      }\n    });\n    return {\n      success: true,\n      projects: {\n        ownedProjects,\n        memberOfProjects\n      }\n    };\n  } catch (error) {\n    console.error(\"Error getting user projects:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve user projects\",\n      errorCode: \"FETCH_USER_PROJECTS_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getActivityFeed(Feed) {\n  try {\n    if (!Feed || !Array.isArray(Feed)) {\n      return {\n        success: false,\n        message: \"Invalid feed format\",\n        errorCode: \"INVALID_FEED_FORMAT\"\n      };\n    }\n    const activityfeed = [];\n    Feed.forEach(f => {\n      if (_mongodb.ObjectId.isValid(f)) {\n        activityfeed.push(new _mongodb.ObjectId(f));\n      }\n    });\n    const activities = await db.collection('activities').find({\n      _id: {\n        $in: activityfeed\n      }\n    }).toArray();\n    return {\n      success: true,\n      activities: activities\n    };\n  } catch (error) {\n    console.error(\"Error getting activity feed:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve activity feed\",\n      errorCode: \"FETCH_ACTIVITY_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getDiscussions(discussions) {\n  try {\n    if (!discussions || !Array.isArray(discussions)) {\n      return {\n        success: false,\n        message: \"Invalid discussions format\",\n        errorCode: \"INVALID_DISCUSSIONS_FORMAT\"\n      };\n    }\n    const iddiscussions = [];\n    discussions.forEach(discussion => {\n      if (_mongodb.ObjectId.isValid(discussion)) {\n        iddiscussions.push(new _mongodb.ObjectId(discussion));\n      }\n    });\n    const discussionsList = await db.collection('discussions').find({\n      _id: {\n        $in: iddiscussions\n      }\n    }).toArray();\n    return {\n      success: true,\n      discussions: discussionsList\n    };\n  } catch (error) {\n    console.error(\"Error getting discussions:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve discussions\",\n      errorCode: \"FETCH_DISCUSSIONS_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getAllTypes() {\n  try {\n    const types = await db.collection('project_types').find({}).toArray();\n    return {\n      success: true,\n      types: types\n    };\n  } catch (error) {\n    console.error(\"Error getting types:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve project types\",\n      errorCode: \"FETCH_TYPES_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getProjectType(Typeid) {\n  try {\n    if (!Typeid) {\n      return {\n        success: false,\n        message: \"Type ID is required\",\n        errorCode: \"MISSING_TYPE_ID\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(Typeid)) {\n      return {\n        success: false,\n        message: \"Invalid type ID format\",\n        errorCode: \"INVALID_TYPE_ID\"\n      };\n    }\n    const objtypeid = new _mongodb.ObjectId(Typeid);\n    const types = await db.collection('project_types').find({\n      _id: {\n        $in: [objtypeid]\n      }\n    }).toArray();\n    if (types.length === 0) {\n      return {\n        success: false,\n        message: \"Project type not found\",\n        errorCode: \"TYPE_NOT_FOUND\"\n      };\n    }\n    return {\n      success: true,\n      types: types\n    };\n  } catch (error) {\n    console.error(\"Error getting project type:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve project type\",\n      errorCode: \"FETCH_PROJECT_TYPE_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getUser(userId) {\n  try {\n    if (!userId) {\n      return {\n        success: false,\n        message: \"User ID is required\",\n        errorCode: \"MISSING_USER_ID\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(userId)) {\n      return {\n        success: false,\n        message: \"Invalid user ID format\",\n        errorCode: \"INVALID_USER_ID\"\n      };\n    }\n    const objectid = new _mongodb.ObjectId(userId);\n    const user = await db.collection('users').findOne({\n      _id: {\n        $in: [objectid]\n      }\n    });\n    if (!user) {\n      return {\n        success: false,\n        message: \"User not found\",\n        errorCode: \"USER_NOT_FOUND\"\n      };\n    }\n    return {\n      success: true,\n      user: user\n    };\n  } catch (error) {\n    console.error(\"Error getting user:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve user\",\n      errorCode: \"FETCH_USER_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function updateUserInfo(user) {\n  try {\n    if (!user._id) {\n      return {\n        success: false,\n        message: \"User ID is required\",\n        errorCode: \"MISSING_USER_ID\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(user._id)) {\n      return {\n        success: false,\n        message: \"Invalid user ID format\",\n        errorCode: \"INVALID_USER_ID\"\n      };\n    }\n    const userId = new _mongodb.ObjectId(user._id);\n    const existingUser = await db.collection('users').findOne({\n      _id: userId\n    });\n    if (!existingUser) {\n      return {\n        success: false,\n        message: \"User not found\",\n        errorCode: \"USER_NOT_FOUND\"\n      };\n    }\n    if (user.username && user.username !== existingUser.username) {\n      const usernameTaken = await db.collection('users').findOne({\n        username: user.username,\n        _id: {\n          $ne: userId\n        }\n      });\n      if (usernameTaken) {\n        return {\n          success: false,\n          message: \"Username is already taken\",\n          errorCode: \"USERNAME_TAKEN\"\n        };\n      }\n    }\n    const updateFields = {\n      username: user.username ?? existingUser.username,\n      email: user.email ?? existingUser.email,\n      name: user.name ?? existingUser.name,\n      surname: user.surname ?? existingUser.surname,\n      personalInfo: {\n        bio: user.personalInfo?.bio ?? existingUser.personalInfo?.bio ?? null,\n        website: user.personalInfo?.website ?? existingUser.personalInfo?.website ?? null,\n        socials: user.personalInfo?.socials ?? existingUser.personalInfo?.socials ?? [],\n        birthday: user.personalInfo?.birthday ?? existingUser.personalInfo?.birthday ?? null,\n        contactInfo: user.personalInfo?.contactInfo ?? existingUser.personalInfo?.contactInfo ?? [],\n        work: user.personalInfo?.work ?? existingUser.personalInfo?.work ?? null\n      },\n      updatedAt: new Date()\n    };\n    await db.collection('users').updateOne({\n      _id: userId\n    }, {\n      $set: updateFields\n    });\n    return {\n      success: true,\n      message: \"User updated successfully\"\n    };\n  } catch (error) {\n    console.error(\"Error updating user:\", error);\n    return {\n      success: false,\n      message: \"Failed to update user\",\n      errorCode: \"UPDATE_USER_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function updateProject(project) {\n  try {\n    if (!project._id) {\n      return {\n        success: false,\n        message: \"Project ID is required\",\n        errorCode: \"MISSING_PROJECT_ID\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(project._id)) {\n      return {\n        success: false,\n        message: \"Invalid project ID format\",\n        errorCode: \"INVALID_PROJECT_ID\"\n      };\n    }\n    const projectId = new _mongodb.ObjectId(project._id);\n    const existingProject = await db.collection(\"projects\").findOne({\n      _id: projectId\n    });\n    if (!existingProject) {\n      return {\n        success: false,\n        message: \"Project not found\",\n        errorCode: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    const updateFields = {};\n    if (project.name !== undefined) updateFields.name = project.name;\n    if (project.description !== undefined) updateFields.description = project.description;\n    if (project.hashtags !== undefined) updateFields.hashtags = project.hashtags;\n    if (project.type !== undefined) {\n      if (!_mongodb.ObjectId.isValid(project.type)) {\n        return {\n          success: false,\n          message: \"Invalid project type ID\",\n          errorCode: \"INVALID_TYPE_ID\"\n        };\n      }\n      updateFields.type = new _mongodb.ObjectId(project.type);\n    }\n    updateFields.updatedAt = new Date();\n    await db.collection(\"projects\").updateOne({\n      _id: projectId\n    }, {\n      $set: updateFields\n    });\n    return {\n      success: true,\n      message: \"Project updated successfully\"\n    };\n  } catch (error) {\n    console.error(\"Error updating project:\", error);\n    return {\n      success: false,\n      message: \"Failed to update project\",\n      errorCode: \"UPDATE_PROJECT_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function createProject(data, ownerId) {\n  try {\n    if (!ownerId) {\n      return {\n        success: false,\n        message: \"Owner ID is required\",\n        errorCode: \"MISSING_OWNER_ID\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(ownerId)) {\n      return {\n        success: false,\n        message: \"Invalid owner ID format\",\n        errorCode: \"INVALID_OWNER_ID\"\n      };\n    }\n    if (!data.projectName) {\n      return {\n        success: false,\n        message: \"Project name is required\",\n        errorCode: \"MISSING_PROJECT_NAME\"\n      };\n    }\n    if (!data.projectType) {\n      return {\n        success: false,\n        message: \"Project type is required\",\n        errorCode: \"MISSING_PROJECT_TYPE\"\n      };\n    }\n    const ownerObjectId = new _mongodb.ObjectId(ownerId);\n    const existingProject = await db.collection(\"projects\").findOne({\n      name: data.projectName,\n      owner: ownerObjectId\n    });\n    if (existingProject) {\n      return {\n        success: false,\n        message: \"You already have a project with this name\",\n        errorCode: \"PROJECT_NAME_EXISTS\"\n      };\n    }\n    let hashtags = [];\n    if (data.projectLanguages) {\n      hashtags = data.projectLanguages.split(\" \").map(tag => tag.replace(/^#/, \"\").trim()).filter(tag => tag.length > 0);\n    }\n    const newProject = {\n      name: data.projectName,\n      description: data.projectDescription,\n      projectImage: data.projectImage || null,\n      type: new _mongodb.ObjectId(data.projectType),\n      hashtags: hashtags,\n      version: data.projectVersion,\n      owner: ownerObjectId,\n      members: [],\n      status: \"checked_out\",\n      checkedOutBy: null,\n      files: [],\n      activityFeed: [],\n      discussionBoard: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      versionHistory: [],\n      image: \"default\"\n    };\n    const insertResult = await db.collection(\"projects\").insertOne(newProject);\n    const projectId = insertResult.insertedId;\n    if (!projectId) {\n      return {\n        success: false,\n        message: 'Failed to create project',\n        errorCode: \"PROJECT_INSERT_FAILED\"\n      };\n    }\n    const userUpdateResult = await db.collection(\"users\").updateOne({\n      _id: ownerObjectId\n    }, {\n      $addToSet: {\n        ownedProjects: projectId\n      }\n    });\n    if (userUpdateResult.matchedCount === 0) {\n      console.warn('User not found, but project was created. Manual cleanup may be needed.');\n      return {\n        success: false,\n        message: 'Project created, but owner user not found. Check user ID.',\n        errorCode: \"USER_UPDATE_FAILED\"\n      };\n    }\n    const createdProject = await db.collection(\"projects\").findOne({\n      _id: projectId\n    });\n    return {\n      success: true,\n      message: \"Project created successfully\",\n      project: createdProject\n    };\n  } catch (error) {\n    console.error(\"Error creating project:\", error);\n    return {\n      success: false,\n      message: \"Failed to create project\",\n      errorCode: \"CREATE_PROJECT_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function sendFriendRequest(senderId, receiverId) {\n  try {\n    if (!senderId || !receiverId) {\n      return {\n        success: false,\n        message: \"Sender and receiver IDs are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(senderId) || !_mongodb.ObjectId.isValid(receiverId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    if (senderId === receiverId) {\n      return {\n        success: false,\n        message: \"Cannot send friend request to yourself\",\n        errorCode: \"SELF_REQUEST\"\n      };\n    }\n    const senderObjectId = new _mongodb.ObjectId(senderId);\n    const receiverObjectId = new _mongodb.ObjectId(receiverId);\n\n    // Check if users exist\n    const sender = await db.collection(\"users\").findOne({\n      _id: senderObjectId\n    });\n    const receiver = await db.collection(\"users\").findOne({\n      _id: receiverObjectId\n    });\n    if (!sender || !receiver) {\n      return {\n        success: false,\n        message: \"One or both users not found\",\n        errorCode: \"USER_NOT_FOUND\"\n      };\n    }\n\n    // Check if already friends\n    if (sender.friends?.some(id => id.equals(receiverObjectId))) {\n      return {\n        success: false,\n        message: \"Users are already friends\",\n        errorCode: \"ALREADY_FRIENDS\"\n      };\n    }\n\n    // Check if request already sent\n    if (sender.friendRequestsSent?.some(id => id.equals(receiverObjectId))) {\n      return {\n        success: false,\n        message: \"Friend request already sent\",\n        errorCode: \"REQUEST_EXISTS\"\n      };\n    }\n    await db.collection(\"users\").updateOne({\n      _id: senderObjectId\n    }, {\n      $addToSet: {\n        friendRequestsSent: receiverObjectId\n      }\n    });\n    await db.collection(\"users\").updateOne({\n      _id: receiverObjectId\n    }, {\n      $addToSet: {\n        friendRequestsReceived: senderObjectId\n      }\n    });\n    return {\n      success: true,\n      message: \"Friend request sent\"\n    };\n  } catch (error) {\n    console.error(\"Error sending friend request:\", error);\n    return {\n      success: false,\n      message: \"Failed to send friend request\",\n      errorCode: \"FRIEND_REQUEST_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function acceptFriendRequest(receiverId, senderId) {\n  try {\n    if (!receiverId || !senderId) {\n      return {\n        success: false,\n        message: \"Receiver and sender IDs are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(receiverId) || !_mongodb.ObjectId.isValid(senderId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const receiverObjectId = new _mongodb.ObjectId(receiverId);\n    const senderObjectId = new _mongodb.ObjectId(senderId);\n\n    // Verify request exists\n    const receiver = await db.collection(\"users\").findOne({\n      _id: receiverObjectId\n    });\n    if (!receiver || !receiver.friendRequestsReceived?.some(id => id.equals(senderObjectId))) {\n      return {\n        success: false,\n        message: \"Friend request not found\",\n        errorCode: \"REQUEST_NOT_FOUND\"\n      };\n    }\n    await db.collection(\"users\").updateOne({\n      _id: receiverObjectId\n    }, {\n      $addToSet: {\n        friends: senderObjectId\n      },\n      $pull: {\n        friendRequestsReceived: senderObjectId\n      }\n    });\n    await db.collection(\"users\").updateOne({\n      _id: senderObjectId\n    }, {\n      $addToSet: {\n        friends: receiverObjectId\n      },\n      $pull: {\n        friendRequestsSent: receiverObjectId\n      }\n    });\n    return {\n      success: true,\n      message: \"Friend request accepted\"\n    };\n  } catch (error) {\n    console.error(\"Error accepting request:\", error);\n    return {\n      success: false,\n      message: \"Failed to accept friend request\",\n      errorCode: \"ACCEPT_REQUEST_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function declineFriendRequest(receiverId, senderId) {\n  try {\n    if (!receiverId || !senderId) {\n      return {\n        success: false,\n        message: \"Receiver and sender IDs are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(receiverId) || !_mongodb.ObjectId.isValid(senderId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const receiverObjectId = new _mongodb.ObjectId(receiverId);\n    const senderObjectId = new _mongodb.ObjectId(senderId);\n    await db.collection(\"users\").updateOne({\n      _id: receiverObjectId\n    }, {\n      $pull: {\n        friendRequestsReceived: senderObjectId\n      }\n    });\n    await db.collection(\"users\").updateOne({\n      _id: senderObjectId\n    }, {\n      $pull: {\n        friendRequestsSent: receiverObjectId\n      }\n    });\n    return {\n      success: true,\n      message: \"Friend request declined\"\n    };\n  } catch (error) {\n    console.error(\"Error declining request:\", error);\n    return {\n      success: false,\n      message: \"Failed to decline friend request\",\n      errorCode: \"DECLINE_REQUEST_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function removeFriend(userId, friendId) {\n  try {\n    if (!userId || !friendId) {\n      return {\n        success: false,\n        message: \"User ID and friend ID are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(userId) || !_mongodb.ObjectId.isValid(friendId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const userObjectId = new _mongodb.ObjectId(userId);\n    const friendObjectId = new _mongodb.ObjectId(friendId);\n    await db.collection(\"users\").updateOne({\n      _id: userObjectId\n    }, {\n      $pull: {\n        friends: friendObjectId\n      }\n    });\n    await db.collection(\"users\").updateOne({\n      _id: friendObjectId\n    }, {\n      $pull: {\n        friends: userObjectId\n      }\n    });\n    return {\n      success: true,\n      message: \"Friend removed successfully\"\n    };\n  } catch (error) {\n    console.error(\"Error removing friend:\", error);\n    return {\n      success: false,\n      message: \"Failed to remove friend\",\n      errorCode: \"REMOVE_FRIEND_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function addActivityEntry({\n  projectId,\n  userId,\n  type,\n  message,\n  projectVersion\n}) {\n  try {\n    if (!projectId || !userId || !type || !message) {\n      return {\n        success: false,\n        message: \"Project ID, user ID, type, and message are required\",\n        errorCode: \"MISSING_FIELDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(projectId) || !_mongodb.ObjectId.isValid(userId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const projectObjectId = new _mongodb.ObjectId(projectId);\n    const userObjectId = new _mongodb.ObjectId(userId);\n    const activityEntry = {\n      projectId: projectObjectId,\n      userId: userObjectId,\n      type: type,\n      message: message,\n      projectVersion: projectVersion || '1.0.0',\n      createdAt: new Date(),\n      downloads: 0\n    };\n    const insertResult = await db.collection(\"activities\").insertOne(activityEntry);\n    const entryId = insertResult.insertedId;\n    if (!entryId) {\n      return {\n        success: false,\n        message: 'Failed to add activity entry',\n        errorCode: \"ACTIVITY_INSERT_FAILED\"\n      };\n    }\n    const createdEntry = await db.collection(\"activities\").findOne({\n      _id: entryId\n    });\n    const addtoproject = await db.collection(\"projects\").updateOne({\n      _id: projectObjectId\n    }, {\n      $addToSet: {\n        activityFeed: entryId\n      }\n    });\n    if (addtoproject.matchedCount === 0) {\n      return {\n        success: true,\n        message: 'Activity entry added successfully but project not found',\n        entry: createdEntry,\n        warning: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    return {\n      success: true,\n      message: 'Activity entry added successfully',\n      entry: createdEntry\n    };\n  } catch (error) {\n    console.error(\"Error adding activity entry:\", error);\n    return {\n      success: false,\n      message: \"Failed to add activity entry\",\n      errorCode: \"ADD_ACTIVITY_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function addDiscussionEntry({\n  projectId,\n  userId,\n  message\n}) {\n  try {\n    if (!projectId || !userId || !message) {\n      return {\n        success: false,\n        message: \"Project ID, user ID, and message are required\",\n        errorCode: \"MISSING_FIELDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(projectId) || !_mongodb.ObjectId.isValid(userId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const projectObjectId = new _mongodb.ObjectId(projectId);\n    const userObjectId = new _mongodb.ObjectId(userId);\n    const discussionEntry = {\n      projectId: projectObjectId,\n      userId: userObjectId,\n      message: message,\n      createdAt: new Date()\n    };\n    const insertResult = await db.collection(\"discussions\").insertOne(discussionEntry);\n    const entryId = insertResult.insertedId;\n    if (!entryId) {\n      return {\n        success: false,\n        message: 'Failed to add discussion entry',\n        errorCode: \"DISCUSSION_INSERT_FAILED\"\n      };\n    }\n    const createdEntry = await db.collection(\"discussions\").findOne({\n      _id: entryId\n    });\n    const addtoproject = await db.collection(\"projects\").updateOne({\n      _id: projectObjectId\n    }, {\n      $addToSet: {\n        discussionBoard: entryId\n      }\n    });\n    if (addtoproject.matchedCount === 0) {\n      return {\n        success: true,\n        message: 'Discussion entry added successfully but project not found',\n        entry: createdEntry,\n        warning: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    return {\n      success: true,\n      message: 'Discussion entry added successfully',\n      entry: createdEntry\n    };\n  } catch (error) {\n    console.error(\"Error adding discussion entry:\", error);\n    return {\n      success: false,\n      message: \"Failed to add discussion entry\",\n      errorCode: \"ADD_DISCUSSION_ERROR\",\n      error: error.message\n    };\n  }\n}\nfunction validateObjectId(id) {\n  if (!_mongodb.ObjectId.isValid(id)) {\n    throw new Error(`Invalid ObjectId: ${id}`);\n  }\n  return new _mongodb.ObjectId(id);\n}\nasync function deleteProject(projectId, requesterId) {\n  try {\n    if (!projectId || !requesterId) {\n      return {\n        success: false,\n        message: \"Project ID and requester ID are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    const projectObjectId = validateObjectId(projectId);\n    const requesterObjectId = validateObjectId(requesterId);\n    const project = await db.collection('projects').findOne({\n      _id: projectObjectId\n    });\n    if (!project) {\n      return {\n        success: false,\n        message: 'Project not found',\n        errorCode: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    if (!project.owner.equals(requesterObjectId)) {\n      return {\n        success: false,\n        message: 'Only the project owner can delete it',\n        errorCode: \"UNAUTHORIZED\"\n      };\n    }\n    await db.collection('activities').deleteMany({\n      projectId: projectObjectId\n    });\n    await db.collection('discussions').deleteMany({\n      projectId: projectObjectId\n    });\n    const affectedUsers = await db.collection('users').find({\n      $or: [{\n        ownedProjects: {\n          $in: [projectObjectId]\n        }\n      }, {\n        memberOfProjects: {\n          $in: [projectObjectId]\n        }\n      }, {\n        pinnedProjects: {\n          $in: [projectObjectId]\n        }\n      }]\n    }).toArray();\n    const uniqueUserIds = [...new Set(affectedUsers.map(user => user._id.toString()))];\n    for (const userIdStr of uniqueUserIds) {\n      const userObjectId = new _mongodb.ObjectId(userIdStr);\n      const updateOps = {\n        $pull: {}\n      };\n      updateOps.$pull.ownedProjects = projectObjectId;\n      updateOps.$pull.memberOfProjects = projectObjectId;\n      updateOps.$pull.pinnedProject = projectObjectId;\n      await db.collection('users').updateOne({\n        _id: userObjectId\n      }, updateOps);\n    }\n    const projectDeleteResult = await db.collection('projects').deleteOne({\n      _id: projectObjectId\n    });\n    if (projectDeleteResult.deletedCount === 0) {\n      return {\n        success: false,\n        message: 'Failed to delete project',\n        errorCode: \"DELETE_FAILED\"\n      };\n    }\n    return {\n      success: true,\n      message: `Project \"${project.name}\" deleted successfully.`\n    };\n  } catch (error) {\n    console.error('Error deleting project:', error);\n    return {\n      success: false,\n      message: \"Failed to delete project\",\n      errorCode: \"DELETE_PROJECT_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function deleteUser(userId, requesterId) {\n  try {\n    if (!userId || !requesterId) {\n      return {\n        success: false,\n        message: \"User ID and requester ID are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (userId !== requesterId) {\n      return {\n        success: false,\n        message: 'You can only delete your own account',\n        errorCode: \"UNAUTHORIZED\"\n      };\n    }\n    const userObjectId = validateObjectId(userId);\n    const user = await db.collection('users').findOne({\n      _id: userObjectId\n    });\n    if (!user) {\n      return {\n        success: false,\n        message: 'User not found',\n        errorCode: \"USER_NOT_FOUND\"\n      };\n    }\n    const ownedProjects = user.ownedProjects || [];\n    let deletedProjectCount = 0;\n    for (const projId of ownedProjects) {\n      const projectResponse = await deleteProject(projId.toString(), userId);\n      if (projectResponse.success) {\n        deletedProjectCount++;\n      } else {\n        console.warn(`Failed to delete owned project ${projId}: ${projectResponse.message}`);\n      }\n    }\n    const memberProjects = await db.collection('projects').find({\n      members: userObjectId\n    }).toArray();\n    for (const project of memberProjects) {\n      await db.collection('projects').updateOne({\n        _id: project._id\n      }, {\n        $pull: {\n          members: userObjectId\n        }\n      });\n    }\n    const friends = user.friends || [];\n    for (const friendId of friends) {\n      await db.collection('users').updateOne({\n        _id: friendId\n      }, {\n        $pull: {\n          friends: userObjectId\n        }\n      });\n    }\n    const sentRequests = user.friendRequestsSent || [];\n    for (const receiverId of sentRequests) {\n      await db.collection('users').updateOne({\n        _id: receiverId\n      }, {\n        $pull: {\n          friendRequestsReceived: userObjectId\n        }\n      });\n    }\n    const receivedRequests = user.friendRequestsReceived || [];\n    for (const senderId of receivedRequests) {\n      await db.collection('users').updateOne({\n        _id: senderId\n      }, {\n        $pull: {\n          friendRequestsSent: userObjectId\n        }\n      });\n    }\n    await db.collection('activities').deleteMany({\n      userId: userObjectId\n    });\n    await db.collection('discussions').deleteMany({\n      userId: userObjectId\n    });\n    const userDeleteResult = await db.collection('users').deleteOne({\n      _id: userObjectId\n    });\n    if (userDeleteResult.deletedCount === 0) {\n      return {\n        success: false,\n        message: 'Failed to delete user',\n        errorCode: \"DELETE_FAILED\"\n      };\n    }\n    return {\n      success: true,\n      message: `User \"${user.username || userId}\" deleted successfully. Deleted ${deletedProjectCount} owned projects, cleaned ${memberProjects.length} memberships, ${friends.length} friendships, and related activities/discussions.`\n    };\n  } catch (error) {\n    console.error('Error deleting user:', error);\n    return {\n      success: false,\n      message: \"Failed to delete user\",\n      errorCode: \"DELETE_USER_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getProject(projectId) {\n  try {\n    if (!projectId) {\n      return {\n        success: false,\n        message: \"Project ID is required\",\n        errorCode: \"MISSING_PROJECT_ID\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(projectId)) {\n      return {\n        success: false,\n        message: \"Invalid project ID format\",\n        errorCode: \"INVALID_PROJECT_ID\"\n      };\n    }\n    const objectid = new _mongodb.ObjectId(projectId);\n    const project = await db.collection('projects').findOne({\n      _id: {\n        $in: [objectid]\n      }\n    });\n    if (!project) {\n      return {\n        success: false,\n        message: \"Project not found\",\n        errorCode: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    return {\n      success: true,\n      project: project\n    };\n  } catch (error) {\n    console.error(\"Error getting project:\", error);\n    return {\n      success: false,\n      message: \"Failed to retrieve project\",\n      errorCode: \"FETCH_PROJECT_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function searchUsers(searchTerm) {\n  try {\n    if (!searchTerm || searchTerm.trim().length === 0) {\n      return {\n        success: false,\n        message: \"Search term is required\",\n        errorCode: \"MISSING_SEARCH_TERM\"\n      };\n    }\n    const users = await db.collection('users').find({\n      username: new RegExp(searchTerm, 'i')\n    }).project({\n      password: 0\n    }).toArray();\n    return {\n      success: true,\n      users: users\n    };\n  } catch (error) {\n    console.error('Error searching users:', error);\n    return {\n      success: false,\n      message: \"Failed to search users\",\n      errorCode: \"SEARCH_USERS_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function searchAll(searchTerm) {\n  try {\n    if (!searchTerm || searchTerm.trim().length < 2) {\n      return {\n        success: true,\n        results: {\n          users: [],\n          projects: [],\n          hashtags: []\n        }\n      };\n    }\n    const regex = new RegExp(searchTerm.trim(), 'i');\n    const users = await db.collection('users').find({\n      username: regex\n    }).project({\n      password: 0,\n      email: 0\n    }).limit(10).toArray();\n    const projectsByName = await db.collection('projects').find({\n      name: regex\n    }).limit(10).toArray();\n    const projectsByHashtag = await db.collection('projects').find({\n      hashtags: regex\n    }).limit(10).toArray();\n    const allProjects = [...new Map([...projectsByName, ...projectsByHashtag].map(p => [p._id, p])).values()];\n    const allHashtags = new Set();\n    allProjects.forEach(project => {\n      project.hashtags?.forEach(tag => {\n        if (regex.test(tag)) {\n          allHashtags.add(tag);\n        }\n      });\n    });\n    const hashtags = Array.from(allHashtags);\n    return {\n      success: true,\n      results: {\n        users: users,\n        projects: allProjects,\n        hashtags: hashtags\n      }\n    };\n  } catch (error) {\n    console.error('Error in searchAll:', error);\n    return {\n      success: false,\n      message: \"Search failed\",\n      errorCode: \"SEARCH_ALL_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function asp() {\n  try {\n    await db.collection(\"projects\").updateMany({}, {\n      $set: {\n        image: \"default\"\n      }\n    });\n    return {\n      success: true,\n      message: \"All projects updated\"\n    };\n  } catch (error) {\n    console.error('Error in asp:', error);\n    return {\n      success: false,\n      message: \"Update failed\",\n      errorCode: \"ASP_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function addMemberToProject(projectId, userId) {\n  try {\n    if (!projectId || !userId) {\n      return {\n        success: false,\n        message: \"Project ID and user ID are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(projectId) || !_mongodb.ObjectId.isValid(userId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const projectObjectId = new _mongodb.ObjectId(projectId);\n    const userObjectId = new _mongodb.ObjectId(userId);\n    const project = await db.collection(\"projects\").findOne({\n      _id: projectObjectId\n    });\n    if (!project) {\n      return {\n        success: false,\n        message: \"Project not found\",\n        errorCode: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    const user = await db.collection(\"users\").findOne({\n      _id: userObjectId\n    });\n    if (!user) {\n      return {\n        success: false,\n        message: \"User not found\",\n        errorCode: \"USER_NOT_FOUND\"\n      };\n    }\n    if (project.owner.toString() === userObjectId.toString() || project.members?.some(m => m.toString() === userObjectId.toString())) {\n      return {\n        success: false,\n        message: \"User is already a member or owner\",\n        errorCode: \"ALREADY_MEMBER\"\n      };\n    }\n    await db.collection(\"projects\").updateOne({\n      _id: projectObjectId\n    }, {\n      $addToSet: {\n        members: userObjectId\n      }\n    });\n    await db.collection(\"users\").updateOne({\n      _id: userObjectId\n    }, {\n      $addToSet: {\n        memberOfProjects: projectObjectId\n      }\n    });\n    return {\n      success: true,\n      message: \"User added as member successfully\"\n    };\n  } catch (error) {\n    console.error(\"Error adding member to project:\", error);\n    return {\n      success: false,\n      message: \"Failed to add member\",\n      errorCode: \"ADD_MEMBER_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function promoteMemberToOwner(projectId, userId) {\n  try {\n    if (!projectId || !userId) {\n      return {\n        success: false,\n        message: \"Project ID and user ID are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(projectId) || !_mongodb.ObjectId.isValid(userId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const projectObjectId = new _mongodb.ObjectId(projectId);\n    const userObjectId = new _mongodb.ObjectId(userId);\n    const project = await db.collection(\"projects\").findOne({\n      _id: projectObjectId\n    });\n    if (!project) {\n      return {\n        success: false,\n        message: \"Project not found\",\n        errorCode: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    const isMember = project.members?.some(m => m.toString() === userObjectId.toString());\n    if (!isMember) {\n      return {\n        success: false,\n        message: \"User must be a member before becoming owner\",\n        errorCode: \"NOT_MEMBER\"\n      };\n    }\n    await db.collection(\"projects\").updateOne({\n      _id: projectObjectId\n    }, {\n      $set: {\n        owner: userObjectId\n      },\n      $pull: {\n        members: userObjectId\n      }\n    });\n    await db.collection(\"users\").updateOne({\n      _id: userObjectId\n    }, {\n      $addToSet: {\n        ownedProjects: projectObjectId\n      },\n      $pull: {\n        memberOfProjects: projectObjectId\n      }\n    });\n    const prevOwnerId = project.owner;\n    if (prevOwnerId) {\n      await db.collection(\"users\").updateOne({\n        _id: new _mongodb.ObjectId(prevOwnerId)\n      }, {\n        $pull: {\n          ownedProjects: projectObjectId\n        },\n        $addToSet: {\n          memberOfProjects: projectObjectId\n        }\n      });\n    }\n    return {\n      success: true,\n      message: \"Member promoted to owner successfully\"\n    };\n  } catch (error) {\n    console.error(\"Error promoting member to owner:\", error);\n    return {\n      success: false,\n      message: \"Failed to promote member\",\n      errorCode: \"PROMOTE_MEMBER_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function pinProjectToUser(userId, projectId) {\n  try {\n    if (!userId || !projectId) {\n      return {\n        success: false,\n        message: \"User ID and project ID are required\",\n        errorCode: \"MISSING_IDS\"\n      };\n    }\n    if (!_mongodb.ObjectId.isValid(userId) || !_mongodb.ObjectId.isValid(projectId)) {\n      return {\n        success: false,\n        message: \"Invalid ID format\",\n        errorCode: \"INVALID_ID_FORMAT\"\n      };\n    }\n    const userObjectId = new _mongodb.ObjectId(userId);\n    const projectObjectId = new _mongodb.ObjectId(projectId);\n    const user = await db.collection(\"users\").findOne({\n      _id: userObjectId\n    });\n    if (!user) {\n      return {\n        success: false,\n        message: \"User not found\",\n        errorCode: \"USER_NOT_FOUND\"\n      };\n    }\n    const project = await db.collection(\"projects\").findOne({\n      _id: projectObjectId\n    });\n    if (!project) {\n      return {\n        success: false,\n        message: \"Project not found\",\n        errorCode: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    const isOwner = project.owner?.toString() === userObjectId.toString();\n    const isMember = project.members?.some(m => m.toString() === userObjectId.toString());\n    if (!isOwner && !isMember) {\n      return {\n        success: false,\n        message: \"User must be an owner or member to pin this project\",\n        errorCode: \"UNAUTHORIZED\"\n      };\n    }\n    await db.collection(\"users\").updateOne({\n      _id: userObjectId\n    }, {\n      $addToSet: {\n        pinnedProjects: projectObjectId\n      }\n    });\n    return {\n      success: true,\n      message: \"Project pinned successfully\"\n    };\n  } catch (error) {\n    console.error(\"Error pinning project:\", error);\n    return {\n      success: false,\n      message: \"Failed to pin project\",\n      errorCode: \"PIN_PROJECT_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getProjectFiles(projectId) {\n  try {\n    if (!_mongodb.ObjectId.isValid(projectId)) {\n      return {\n        success: false,\n        message: \"Invalid project ID format\",\n        errorCode: \"INVALID_PROJECT_ID\"\n      };\n    }\n    const db = await connectToMongoDB();\n    const project = await db.collection(\"projects\").findOne({\n      _id: new _mongodb.ObjectId(projectId)\n    }, {\n      projection: {\n        files: 1\n      }\n    });\n    if (!project) {\n      return {\n        success: false,\n        message: \"Project not found\",\n        errorCode: \"PROJECT_NOT_FOUND\"\n      };\n    }\n    return {\n      success: true,\n      message: \"Files fetched successfully\",\n      files: project.files || []\n    };\n  } catch (error) {\n    console.error(\"Error in getProjectFiles:\", error);\n    return {\n      success: false,\n      message: \"Error fetching project files\",\n      errorCode: \"FETCH_FILES_ERROR\",\n      error: error.message\n    };\n  }\n}\nasync function getUserById(userId) {\n  try {\n    if (!_mongodb.ObjectId.isValid(userId)) {\n      return {\n        success: false,\n        message: \"Invalid user ID format\"\n      };\n    }\n    const user = await db.collection(\"users\").findOne({\n      _id: new _mongodb.ObjectId(userId)\n    }, {\n      projection: {\n        password: 0,\n        // exclude sensitive data\n        verificationRequest: 0\n      }\n    });\n    if (!user) {\n      return {\n        success: false,\n        message: \"User not found\"\n      };\n    }\n    return {\n      success: true,\n      user\n    };\n  } catch (error) {\n    console.error(\"Error fetching user by ID:\", error);\n    return {\n      success: false,\n      message: error.message\n    };\n  }\n}\n\n//# sourceURL=webpack://veyo_imy220_project/./backend/api.js?\n}");

/***/ }),

/***/ "./backend/server.js":
/*!***************************!*\
  !*** ./backend/server.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.upload = exports.profileUpload = void 0;\nvar _express = _interopRequireDefault(__webpack_require__(/*! express */ \"express\"));\nvar _path = _interopRequireDefault(__webpack_require__(/*! path */ \"path\"));\nvar _url = __webpack_require__(/*! url */ \"url\");\nvar api = _interopRequireWildcard(__webpack_require__(/*! ../backend/api */ \"./backend/api.js\"));\nvar _multer = _interopRequireDefault(__webpack_require__(/*! multer */ \"multer\"));\nvar _fs = _interopRequireDefault(__webpack_require__(/*! fs */ \"fs\"));\nvar _mongodb = __webpack_require__(/*! mongodb */ \"mongodb\");\nvar _react = __webpack_require__(/*! react */ \"react\");\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst _filename = (0, _url.fileURLToPath)(\"file:///C:/Users/Okail/OneDrive/Desktop/IMY220/project/u23527685IMY220Project/backend/server.js\");\nconst _dirname = _path.default.dirname(_filename);\nconst app = (0, _express.default)();\nconst port = process.env.PORT || 3000;\napp.use(_express.default.json());\napp.use(_express.default.urlencoded({\n  extended: true\n}));\napp.use(_express.default.static(\"frontend/public\"));\n\n// Error code to HTTP status code mapping\nconst errorCodeToStatus = {\n  // 400 - Bad Request\n  MISSING_CREDENTIALS: 400,\n  MISSING_FIELDS: 400,\n  MISSING_USER_ID: 400,\n  MISSING_PROJECT_ID: 400,\n  MISSING_TYPE_ID: 400,\n  MISSING_IDS: 400,\n  MISSING_OWNER_ID: 400,\n  MISSING_PROJECT_NAME: 400,\n  MISSING_PROJECT_TYPE: 400,\n  MISSING_SEARCH_TERM: 400,\n  MISSING_FILE: 400,\n  MISSING_FILENAME: 400,\n  INVALID_EMAIL: 400,\n  INVALID_USER_ID: 400,\n  INVALID_PROJECT_ID: 400,\n  INVALID_TYPE_ID: 400,\n  INVALID_ID_FORMAT: 400,\n  INVALID_OWNER_ID: 400,\n  INVALID_FEED_FORMAT: 400,\n  INVALID_DISCUSSIONS_FORMAT: 400,\n  SELF_REQUEST: 400,\n  REQUEST_INCORRECT: 400,\n  // 401 - Unauthorized\n  INVALID_CREDENTIALS: 401,\n  // 403 - Forbidden\n  UNAUTHORIZED: 403,\n  // 404 - Not Found\n  USER_NOT_FOUND: 404,\n  PROJECT_NOT_FOUND: 404,\n  TYPE_NOT_FOUND: 404,\n  REQUEST_NOT_FOUND: 404,\n  FILE_NOT_FOUND: 404,\n  ENDPOINT_NOT_FOUND: 404,\n  // 409 - Conflict\n  USER_EXISTS: 409,\n  USERNAME_TAKEN: 409,\n  PROJECT_NAME_EXISTS: 409,\n  ALREADY_FRIENDS: 409,\n  ALREADY_MEMBER: 409,\n  REQUEST_EXISTS: 409,\n  // 422 - Unprocessable Entity\n  NOT_MEMBER: 422,\n  // 500 - Internal Server Error (default)\n  AUTH_ERROR: 500,\n  SIGNUP_ERROR: 500,\n  FETCH_PROJECTS_ERROR: 500,\n  FETCH_USER_PROJECTS_ERROR: 500,\n  FETCH_ACTIVITY_ERROR: 500,\n  FETCH_DISCUSSIONS_ERROR: 500,\n  FETCH_TYPES_ERROR: 500,\n  FETCH_PROJECT_TYPE_ERROR: 500,\n  FETCH_USER_ERROR: 500,\n  FETCH_PROJECT_ERROR: 500,\n  FETCH_FILES_ERROR: 500,\n  FETCH_FILE_ERROR: 500,\n  UPDATE_USER_ERROR: 500,\n  UPDATE_PROJECT_ERROR: 500,\n  CREATE_PROJECT_ERROR: 500,\n  PROJECT_INSERT_FAILED: 500,\n  USER_UPDATE_FAILED: 500,\n  FRIEND_REQUEST_ERROR: 500,\n  ACCEPT_REQUEST_ERROR: 500,\n  DECLINE_REQUEST_ERROR: 500,\n  REMOVE_FRIEND_ERROR: 500,\n  ADD_ACTIVITY_ERROR: 500,\n  ACTIVITY_INSERT_FAILED: 500,\n  ADD_DISCUSSION_ERROR: 500,\n  DISCUSSION_INSERT_FAILED: 500,\n  DELETE_PROJECT_ERROR: 500,\n  DELETE_USER_ERROR: 500,\n  DELETE_FAILED: 500,\n  SEARCH_USERS_ERROR: 500,\n  SEARCH_ALL_ERROR: 500,\n  ADD_MEMBER_ERROR: 500,\n  PROMOTE_MEMBER_ERROR: 500,\n  PIN_PROJECT_ERROR: 500,\n  ASP_ERROR: 500,\n  UPLOAD_ERROR: 500,\n  FILE_TOO_LARGE: 400,\n  SERVER_ERROR: 500\n};\n\n// Helper function to get appropriate status code\nfunction getStatusCode(errorCode) {\n  return errorCodeToStatus[errorCode] || 500;\n}\n\n// Handle all React Router routes\napp.get('/', (req, res) => {\n  res.sendFile(_path.default.resolve('frontend', 'public', 'index.html'));\n});\napp.get('/home', (req, res) => {\n  res.sendFile(_path.default.resolve('frontend', 'public', 'index.html'));\n});\napp.get('/profile', (req, res) => {\n  res.sendFile(_path.default.resolve('frontend', 'public', 'index.html'));\n});\napp.get('/profile/:username', (req, res) => {\n  res.sendFile(_path.default.resolve('frontend', 'public', 'index.html'));\n});\napp.get('/project/:name/:owner/:projectId', (req, res) => {\n  res.sendFile(_path.default.resolve('frontend', 'public', 'index.html'));\n});\napp.get('/project/:name/:owner', (req, res) => {\n  res.sendFile(_path.default.resolve('frontend', 'public', 'index.html'));\n});\napp.use(\"/uploads\", _express.default.static(_path.default.join(process.cwd(), \"uploads\")));\n\n// File upload configuration\nconst uploadDir = _path.default.join(process.cwd(), \"uploads\");\nif (!_fs.default.existsSync(uploadDir)) _fs.default.mkdirSync(uploadDir);\nconst storage = _multer.default.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, uploadDir);\n  },\n  filename: function (req, file, cb) {\n    const projectId = req.params.projectId;\n    const uniqueName = `${projectId}_${file.originalname}`;\n    cb(null, uniqueName);\n  }\n});\nconst upload = exports.upload = (0, _multer.default)({\n  storage\n});\n\n// ---------- PROFILE UPLOADS ----------\nconst profileUploadDir = _path.default.join(process.cwd(), \"profiles\");\nif (!_fs.default.existsSync(profileUploadDir)) _fs.default.mkdirSync(profileUploadDir);\nconst profileStorage = _multer.default.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, profileUploadDir);\n  },\n  filename: function (req, file, cb) {\n    const userId = req.params.userId;\n    const uniqueName = `${userId}_profile${_path.default.extname(file.originalname)}`;\n    cb(null, uniqueName);\n  }\n});\nconst profileUpload = exports.profileUpload = (0, _multer.default)({\n  storage: profileStorage\n});\n// API Routes\n\napp.get(\"/api/projects\", async (req, res) => {\n  try {\n    const projects = await api.getAllProjects();\n    if (projects.success) {\n      res.status(200).json(projects);\n    } else {\n      const statusCode = getStatusCode(projects.errorCode);\n      res.status(statusCode).json(projects);\n    }\n  } catch (error) {\n    console.error('Error in /api/projects:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.get(\"/api/projects/:userid\", async (req, res) => {\n  try {\n    const {\n      userid\n    } = req.params;\n    if (!userid) {\n      return res.status(400).json({\n        success: false,\n        message: 'User ID is required',\n        errorCode: 'MISSING_USER_ID'\n      });\n    }\n    const projects = await api.userProjects(userid);\n    if (projects.success) {\n      res.status(200).json(projects);\n    } else {\n      const statusCode = getStatusCode(projects.errorCode);\n      res.status(statusCode).json(projects);\n    }\n  } catch (error) {\n    console.error('Error in /api/projects/:userid:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/signup\", async (req, res) => {\n  try {\n    const {\n      username,\n      password,\n      email\n    } = req.body;\n    if (!username || !password || !email) {\n      return res.status(400).json({\n        success: false,\n        message: 'Username, password, and email are required',\n        errorCode: 'MISSING_FIELDS'\n      });\n    }\n    const newuser = await api.signupUser(req.body);\n    if (newuser.success) {\n      res.status(201).json(newuser);\n    } else {\n      const statusCode = getStatusCode(newuser.errorCode);\n      res.status(statusCode).json(newuser);\n    }\n  } catch (error) {\n    console.error('Error in /api/signup:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/login\", async (req, res) => {\n  try {\n    const {\n      username,\n      password\n    } = req.body;\n    if (!username || !password) {\n      return res.status(400).json({\n        success: false,\n        message: 'Username and password are required',\n        errorCode: 'MISSING_CREDENTIALS'\n      });\n    }\n    const result = await api.authenticateUser(req.body);\n    if (result.success) {\n      res.status(200).json(result);\n    } else {\n      const statusCode = getStatusCode(result.errorCode);\n      res.status(statusCode).json(result);\n    }\n  } catch (error) {\n    console.error('Error in /api/login:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/project/feed\", async (req, res) => {\n  try {\n    if (!req.body || !Array.isArray(req.body)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid feed format',\n        errorCode: 'INVALID_FEED_FORMAT'\n      });\n    }\n    const feed = await api.getActivityFeed(req.body);\n    if (feed.success) {\n      res.status(200).json(feed);\n    } else {\n      const statusCode = getStatusCode(feed.errorCode);\n      res.status(statusCode).json(feed);\n    }\n  } catch (error) {\n    console.error('Error in /api/project/feed:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/project/discussions\", async (req, res) => {\n  try {\n    if (!req.body || !Array.isArray(req.body)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid discussions format',\n        errorCode: 'INVALID_DISCUSSIONS_FORMAT'\n      });\n    }\n    const discussions = await api.getDiscussions(req.body);\n    if (discussions.success) {\n      res.status(200).json(discussions);\n    } else {\n      const statusCode = getStatusCode(discussions.errorCode);\n      res.status(statusCode).json(discussions);\n    }\n  } catch (error) {\n    console.error('Error in /api/project/discussions:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.get(\"/api/types\", async (req, res) => {\n  try {\n    const types = await api.getAllTypes();\n    if (types.success) {\n      res.status(200).json(types);\n    } else {\n      const statusCode = getStatusCode(types.errorCode);\n      res.status(statusCode).json(types);\n    }\n  } catch (error) {\n    console.error('Error in /api/types:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.get(\"/api/types/:typeid\", async (req, res) => {\n  try {\n    const {\n      typeid\n    } = req.params;\n    if (!typeid) {\n      return res.status(400).json({\n        success: false,\n        message: 'Type ID is required',\n        errorCode: 'MISSING_TYPE_ID'\n      });\n    }\n    const types = await api.getProjectType(typeid);\n    if (types.success) {\n      res.status(200).json(types);\n    } else {\n      const statusCode = getStatusCode(types.errorCode);\n      res.status(statusCode).json(types);\n    }\n  } catch (error) {\n    console.error('Error in /api/types/:typeid:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.get(\"/api/user/:userid\", async (req, res) => {\n  try {\n    const {\n      userid\n    } = req.params;\n    if (!userid) {\n      return res.status(400).json({\n        success: false,\n        message: 'User ID is required',\n        errorCode: 'MISSING_USER_ID'\n      });\n    }\n    const user = await api.getUser(userid);\n    if (user.success) {\n      res.status(200).json(user);\n    } else {\n      const statusCode = getStatusCode(user.errorCode);\n      res.status(statusCode).json(user);\n    }\n  } catch (error) {\n    console.error('Error in /api/user/:userid:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.get(\"/ap/project/:projectId\", async (req, res) => {\n  try {\n    const {\n      projectId\n    } = req.params;\n    if (!projectId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID is required',\n        errorCode: 'MISSING_PROJECT_ID'\n      });\n    }\n    const project = await api.getProject(projectId);\n    if (project.success) {\n      res.status(200).json(project);\n    } else {\n      const statusCode = getStatusCode(project.errorCode);\n      res.status(statusCode).json(project);\n    }\n  } catch (error) {\n    console.error('Error in /ap/project/:projectId:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.put(\"/api/user\", async (req, res) => {\n  try {\n    const {\n      _id,\n      ...updateData\n    } = req.body;\n    if (!_id || typeof _id !== 'string') {\n      return res.status(400).json({\n        success: false,\n        message: 'User ID is required and must be a string',\n        errorCode: 'MISSING_USER_ID'\n      });\n    }\n    const response = await api.updateUserInfo(req.body);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error(\"Error in /api/user PUT:\", error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.put(\"/api/project\", async (req, res) => {\n  try {\n    if (!req.body._id) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID is required',\n        errorCode: 'MISSING_PROJECT_ID'\n      });\n    }\n    const response = await api.updateProject(req.body);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error(\"Error in /api/project PUT:\", error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/projects/create\", async (req, res) => {\n  try {\n    const {\n      ownerId,\n      projectName,\n      projectType\n    } = req.body;\n    if (!ownerId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Owner ID is required',\n        errorCode: 'MISSING_OWNER_ID'\n      });\n    }\n    if (!projectName) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project name is required',\n        errorCode: 'MISSING_PROJECT_NAME'\n      });\n    }\n    if (!projectType) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project type is required',\n        errorCode: 'MISSING_PROJECT_TYPE'\n      });\n    }\n    const response = await api.createProject(req.body, ownerId);\n    if (response.success) {\n      res.status(201).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error(\"Error in /api/projects/create:\", error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post('/api/friends/request', async (req, res) => {\n  try {\n    const {\n      receiverId,\n      senderId\n    } = req.body;\n    if (!senderId || !receiverId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Sender and receiver IDs are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    if (senderId === receiverId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Cannot send friend request to yourself',\n        errorCode: 'SELF_REQUEST'\n      });\n    }\n    const response = await api.sendFriendRequest(senderId, receiverId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/friends/request:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post('/api/friends/accept', async (req, res) => {\n  try {\n    const {\n      senderId,\n      receiverId\n    } = req.body;\n    if (!senderId || !receiverId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Sender and receiver IDs are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    if (receiverId === senderId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Cannot accept your own request',\n        errorCode: 'SELF_REQUEST'\n      });\n    }\n    const response = await api.acceptFriendRequest(receiverId, senderId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/friends/accept:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post('/api/friends/decline', async (req, res) => {\n  try {\n    const {\n      senderId,\n      receiverId\n    } = req.body;\n    if (!senderId || !receiverId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Sender and receiver IDs are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    if (receiverId === senderId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Cannot decline your own request',\n        errorCode: 'SELF_REQUEST'\n      });\n    }\n    const response = await api.declineFriendRequest(receiverId, senderId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/friends/decline:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post('/api/friends/remove', async (req, res) => {\n  try {\n    const {\n      friendId,\n      userId\n    } = req.body;\n    if (!userId || !friendId) {\n      return res.status(400).json({\n        success: false,\n        message: 'User ID and friend ID are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    if (userId === friendId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Cannot remove yourself as a friend',\n        errorCode: 'SELF_REQUEST'\n      });\n    }\n    const response = await api.removeFriend(userId, friendId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/friends/remove:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/activity\", async (req, res) => {\n  try {\n    const {\n      projectId,\n      userId,\n      type,\n      message\n    } = req.body;\n    if (!projectId || !userId || !type || !message) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID, user ID, type, and message are required',\n        errorCode: 'MISSING_FIELDS'\n      });\n    }\n    const response = await api.addActivityEntry(req.body);\n    if (response.success) {\n      res.status(201).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/activity:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/discussion\", async (req, res) => {\n  try {\n    const {\n      projectId,\n      userId,\n      message\n    } = req.body;\n    if (!projectId || !userId || !message) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID, user ID, and message are required',\n        errorCode: 'MISSING_FIELDS'\n      });\n    }\n    const response = await api.addDiscussionEntry(req.body);\n    if (response.success) {\n      res.status(201).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/discussion:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.delete('/api/projects/:projectId/:requesterId', async (req, res) => {\n  try {\n    const {\n      projectId,\n      requesterId\n    } = req.params;\n    if (!projectId || !requesterId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID and requester ID are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    const response = await api.deleteProject(projectId, requesterId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in DELETE /api/projects/:projectId/:requesterId:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.delete('/api/users/:userId/:requesterId', async (req, res) => {\n  try {\n    const {\n      userId,\n      requesterId\n    } = req.params;\n    if (!userId || !requesterId) {\n      return res.status(400).json({\n        success: false,\n        message: 'User ID and requester ID are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    if (userId !== requesterId) {\n      return res.status(403).json({\n        success: false,\n        message: 'You can only delete your own account',\n        errorCode: 'UNAUTHORIZED'\n      });\n    }\n    const response = await api.deleteUser(userId, requesterId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in DELETE /api/users/:userId/:requesterId:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.get(\"/api/users/search\", async (req, res) => {\n  try {\n    const {\n      q\n    } = req.query;\n    if (!q) {\n      return res.status(400).json({\n        success: false,\n        message: \"Search term 'q' is required\",\n        errorCode: 'MISSING_SEARCH_TERM'\n      });\n    }\n    const response = await api.searchUsers(q);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/users/search:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.get(\"/api/search\", async (req, res) => {\n  try {\n    const {\n      q: searchTerm\n    } = req.query;\n    if (!searchTerm) {\n      return res.status(400).json({\n        success: false,\n        message: \"Search term 'q' is required\",\n        errorCode: 'MISSING_SEARCH_TERM'\n      });\n    }\n    const response = await api.searchAll(searchTerm);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/search:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/projects/add-member\", async (req, res) => {\n  try {\n    const {\n      projectId,\n      userId\n    } = req.body;\n    if (!projectId || !userId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID and user ID are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    const response = await api.addMemberToProject(projectId, userId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/projects/add-member:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/projects/promote\", async (req, res) => {\n  try {\n    const {\n      projectId,\n      userId\n    } = req.body;\n    if (!projectId || !userId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID and user ID are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    const response = await api.promoteMemberToOwner(projectId, userId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/projects/promote:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/users/pin\", async (req, res) => {\n  try {\n    const {\n      userId,\n      projectId\n    } = req.body;\n    if (!userId || !projectId) {\n      return res.status(400).json({\n        success: false,\n        message: 'User ID and project ID are required',\n        errorCode: 'MISSING_IDS'\n      });\n    }\n    const response = await api.pinProjectToUser(userId, projectId);\n    if (response.success) {\n      res.status(200).json(response);\n    } else {\n      const statusCode = getStatusCode(response.errorCode);\n      res.status(statusCode).json(response);\n    }\n  } catch (error) {\n    console.error('Error in /api/users/pin:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Internal server error',\n      errorCode: 'SERVER_ERROR'\n    });\n  }\n});\napp.post(\"/api/projects/:projectId/upload\", upload.single(\"file\"), async (req, res) => {\n  try {\n    const {\n      projectId\n    } = req.params;\n    if (!_mongodb.ObjectId.isValid(projectId)) {\n      return res.status(400).json({\n        success: false,\n        message: \"Invalid project ID\"\n      });\n    }\n    if (!req.file) {\n      return res.status(400).json({\n        success: false,\n        message: \"No file uploaded\"\n      });\n    }\n    const db = await api.connectToMongoDB();\n    const projectObjectId = new _mongodb.ObjectId(projectId);\n    const project = await db.collection(\"projects\").findOne({\n      _id: projectObjectId\n    });\n    if (!project) {\n      _fs.default.unlinkSync(req.file.path);\n      return res.status(404).json({\n        success: false,\n        message: \"Project not found\"\n      });\n    }\n    const fileName = req.file.originalname;\n    const storedName = `${projectId}_${fileName}`;\n    const filePath = _path.default.join(uploadDir, storedName);\n\n    // If existing file with same name, delete it first\n    if (_fs.default.existsSync(filePath) && filePath !== req.file.path) {\n      _fs.default.unlinkSync(filePath);\n    }\n    const fileData = {\n      fileName,\n      filePath: `/uploads/${storedName}`,\n      fileSize: req.file.size,\n      uploadedAt: new Date(),\n      lastModifiedAt: new Date()\n    };\n\n    // Update DB: replace old file entry if it exists\n    await db.collection(\"projects\").updateOne({\n      _id: projectObjectId\n    }, {\n      $pull: {\n        files: {\n          fileName\n        }\n      },\n      $push: {\n        files: fileData\n      }\n    });\n    res.status(201).json({\n      success: true,\n      message: \"File uploaded/updated successfully\",\n      file: fileData\n    });\n  } catch (error) {\n    console.error(\"Error uploading project file:\", error);\n    if (req.file && _fs.default.existsSync(req.file.path)) _fs.default.unlinkSync(req.file.path);\n    res.status(500).json({\n      success: false,\n      message: \"Upload failed\",\n      error: error.message\n    });\n  }\n});\napp.post(\"/api/user/:userId/upload\", profileUpload.single(\"file\"), async (req, res) => {\n  try {\n    const {\n      userId\n    } = req.params;\n    if (!_mongodb.ObjectId.isValid(userId)) {\n      return res.status(400).json({\n        success: false,\n        message: \"Invalid user ID\"\n      });\n    }\n    if (!req.file) {\n      return res.status(400).json({\n        success: false,\n        message: \"No file uploaded\"\n      });\n    }\n    const db = await api.connectToMongoDB();\n    const userObjectId = new _mongodb.ObjectId(userId);\n    const user = await db.collection(\"users\").findOne({\n      _id: userObjectId\n    });\n    if (!user) {\n      _fs.default.unlinkSync(req.file.path);\n      return res.status(404).json({\n        success: false,\n        message: \"User not found\"\n      });\n    }\n    const storedName = `${userId}_profile${_path.default.extname(req.file.originalname)}`;\n    const filePath = _path.default.join(profileUploadDir, storedName);\n\n    // Overwrite existing file if it exists\n    if (_fs.default.existsSync(filePath) && filePath !== req.file.path) {\n      _fs.default.unlinkSync(filePath);\n    }\n    const fileData = {\n      fileName: req.file.originalname,\n      filePath: `/profiles/${storedName}`,\n      fileSize: req.file.size,\n      uploadedAt: new Date(),\n      lastModifiedAt: new Date()\n    };\n\n    // Update user's profile picture in DB\n    await db.collection(\"users\").updateOne({\n      _id: userObjectId\n    }, {\n      $set: {\n        profilePicture: fileData\n      }\n    });\n    res.status(201).json({\n      success: true,\n      message: \"Profile picture uploaded/updated successfully\",\n      file: fileData\n    });\n  } catch (error) {\n    console.error(\"Error uploading profile picture:\", error);\n    if (req.file && _fs.default.existsSync(req.file.path)) _fs.default.unlinkSync(req.file.path);\n    res.status(500).json({\n      success: false,\n      message: \"Upload failed\",\n      error: error.message\n    });\n  }\n});\napp.get(\"/api/projects/:projectId/files\", async (req, res) => {\n  try {\n    const {\n      projectId\n    } = req.params;\n    if (!projectId) {\n      return res.status(400).json({\n        success: false,\n        message: \"Project ID is required\",\n        errorCode: \"MISSING_PROJECT_ID\"\n      });\n    }\n    const response = await api.getProjectFiles(projectId);\n    if (response.success) {\n      return res.status(200).json(response);\n    }\n    const statusCode = getStatusCode(response.errorCode);\n    return res.status(statusCode).json(response);\n  } catch (error) {\n    console.error(\"Error in /api/projects/:projectId/files:\", error);\n    return res.status(500).json({\n      success: false,\n      message: \"Internal server error\",\n      errorCode: \"SERVER_ERROR\",\n      error: error.message\n    });\n  }\n});\napp.get(\"/api/projects/:projectId/files/:filename\", async (req, res) => {\n  try {\n    const {\n      projectId,\n      filename\n    } = req.params;\n    if (!projectId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Project ID is required',\n        errorCode: 'MISSING_PROJECT_ID'\n      });\n    }\n    if (!filename) {\n      return res.status(400).json({\n        success: false,\n        message: 'Filename is required',\n        errorCode: 'MISSING_FILENAME'\n      });\n    }\n    const filePath = _path.default.join(process.cwd(), \"uploads\", `${projectId}_${filename}`);\n    if (!_fs.default.existsSync(filePath)) {\n      return res.status(404).json({\n        success: false,\n        message: \"File not found\",\n        errorCode: 'FILE_NOT_FOUND'\n      });\n    }\n    res.sendFile(filePath);\n  } catch (error) {\n    console.error(\"Error serving file:\", error);\n    res.status(500).json({\n      success: false,\n      message: \"Error fetching file\",\n      errorCode: 'FETCH_FILE_ERROR',\n      error: error.message\n    });\n  }\n});\napp.get(\"/api/users/:userId/profile\", async (req, res) => {\n  try {\n    const {\n      userId\n    } = req.params;\n    if (!userId) {\n      return res.status(400).json({\n        success: false,\n        message: \"User ID is required\",\n        errorCode: \"MISSING_USER_ID\"\n      });\n    }\n    const profileDir = _path.default.join(process.cwd(), \"profiles\");\n    if (!_fs.default.existsSync(profileDir)) {\n      return res.status(404).json({\n        success: false,\n        message: \"Profile directory not found\",\n        errorCode: \"DIR_NOT_FOUND\"\n      });\n    }\n\n    // Dynamically find the correct file (any extension)\n    const files = _fs.default.readdirSync(profileDir);\n    const matchingFile = files.find(f => f.startsWith(`${userId}_profile`));\n    if (!matchingFile) {\n      return res.status(404).json({\n        success: false,\n        message: \"Profile image not found\",\n        errorCode: \"FILE_NOT_FOUND\"\n      });\n    }\n    const filePath = _path.default.join(profileDir, matchingFile);\n    res.sendFile(filePath);\n  } catch (error) {\n    console.error(\"Error serving profile image:\", error);\n    res.status(500).json({\n      success: false,\n      message: \"Error fetching file\",\n      errorCode: \"FETCH_FILE_ERROR\",\n      error: error.message\n    });\n  }\n});\napp.get(\"/api/user/:userId\", async (req, res) => {\n  try {\n    const {\n      userId\n    } = req.params;\n    if (!userId) {\n      return res.status(400).json({\n        success: false,\n        message: \"User ID is required\"\n      });\n    }\n    const response = await api.getUserById(userId);\n    if (!response.success) {\n      const status = response.message === \"User not found\" ? 404 : 400;\n      return res.status(status).json(response);\n    }\n    res.json(response);\n  } catch (error) {\n    console.error(\"Error in GET /api/user/:userId:\", error);\n    res.status(500).json({\n      success: false,\n      message: \"Internal server error\",\n      error: error.message\n    });\n  }\n});\n\n// Global error handler middleware\napp.use((err, req, res, next) => {\n  console.error('Unhandled error:', err);\n\n  // Handle Multer errors\n  if (err instanceof _multer.default.MulterError) {\n    if (err.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({\n        success: false,\n        message: 'File too large',\n        errorCode: 'FILE_TOO_LARGE'\n      });\n    }\n    return res.status(400).json({\n      success: false,\n      message: err.message,\n      errorCode: 'UPLOAD_ERROR'\n    });\n  }\n\n  // Handle other errors\n  res.status(500).json({\n    success: false,\n    message: 'Internal server error',\n    errorCode: 'SERVER_ERROR',\n    error:  true ? err.message : 0\n  });\n});\n\n// 404 handler for API routes\napp.use('/api', (req, res) => {\n  res.status(404).json({\n    success: false,\n    message: 'API endpoint not found',\n    errorCode: 'ENDPOINT_NOT_FOUND'\n  });\n});\n\n// Start server\nasync function startServer() {\n  try {\n    await api.connectToMongoDB();\n    app.listen(port, () => {\n      console.log(`Server running on http://localhost:${port}`);\n    });\n  } catch (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\nShutting down gracefully...');\n  try {\n    await api.closeDatabaseConnection();\n    console.log('Database connection closed');\n    process.exit(0);\n  } catch (error) {\n    console.error('Error during shutdown:', error);\n    process.exit(1);\n  }\n});\nprocess.on('SIGTERM', async () => {\n  console.log('\\nReceived SIGTERM, shutting down gracefully...');\n  try {\n    await api.closeDatabaseConnection();\n    console.log('Database connection closed');\n    process.exit(0);\n  } catch (error) {\n    console.error('Error during shutdown:', error);\n    process.exit(1);\n  }\n});\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', error => {\n  console.error('Uncaught Exception:', error);\n  process.exit(1);\n});\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  process.exit(1);\n});\nstartServer();\n\n//# sourceURL=webpack://veyo_imy220_project/./backend/server.js?\n}");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("dotenv");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("express");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("multer");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./backend/server.js");
/******/ 	
/******/ })()
;